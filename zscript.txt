version "3.2.0"

/* MIT License
 *
 * Copyright (c) 2018 Alexander Kromm (mmaulwurff@gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* This code is based on StrongholdEventHandler by Ed the Bat.
 * (https://github.com/Realm667/Re-Releases/blob/master/stronghold/zscript.txt)
 */

class m8f_is_EventHandler : StaticEventHandler
{

  override void PlayerEntered(PlayerEvent e)
  {
    if (IsTitleMap()) { return; }

    bool pistolStart = CVar.FindCVar("m8f_wm_PistolStart").GetInt();
    if (!pistolStart) { return; }

    let player = PlayerPawn(players[e.PlayerNumber].mo);
    ResetInventory(player);
    ResetWeapons(player);
    ResetAmmo(player);
    MaybeAddBackpack(player);
  }

  override Void NetworkProcess(ConsoleEvent e)
  {
    if(e.name == 'keep_this_weapon')
    {
      Weapon currentWeapon = players[e.player].ReadyWeapon;
      if (currentWeapon == null) { return; }
      string currentWeaponClass = currentWeapon.GetClassName();

      CVar keepWeaponsCVar = CVar.FindCVar("m8f_is_KeepWeapons");
      string keeped = keepWeaponsCVar.GetString();

      keeped.AppendFormat("%s,", currentWeaponClass);
      keepWeaponsCVar.SetString(keeped);

      Console.Printf("%s will be kept on new level start.", currentWeapon.GetTag());
    }
    else if (e.name == "clear_keep_weapons")
    {
      CVar.FindCVar("m8f_is_KeepWeapons").SetString("");
      Console.Printf("Weapon keep list is cleared.");
    }
  }

  // private: //////////////////////////////////////////////////////////////////

  /** resets health, armor, and droppable inventory items
   */
  private void ResetInventory(PlayerPawn player)
  {
    // reset health and armor
    player.A_SetHealth(player.GetSpawnHealth());
    player.SetInventory("BasicArmor", 0);
    player.SetInventory("HexenArmor", 1);

    // remove everything that is droppable
    Array<string> items;
    Array<int>    itemAmounts;
    GetKeepWeapons();
    for (let item = player.Inv; item; item = item.Inv)
    {
      if(!item.bUNDROPPABLE && !WeaponIsInKeepList(item.GetClassName()))
      {
        items.push(item.GetClassName());
        itemAmounts.push(item.amount);
      }
    }
    int size = items.Size();
    for (int i = 0; i < size; ++i)
    {
      player.A_TakeInventory(items[i], itemAmounts[i]);
    }

    // Restore default things
    DropItem drop = player.GetDropItems();
    if (drop != null)
    {
      for(DropItem di = drop; di != null; di=di.Next)
      {
        if(di.Name == 'None') { continue; }

        let weapon = (class<Weapon>)(di.Name);
        if (weapon != null) { continue; }

        let ammo = (class<Ammo>)(di.Name);
        if (ammo != null) { continue; }

        let inv = (class<Inventory>)(di.Name);

        if(inv != null)
        {
          player.A_SetInventory(di.Name, di.Amount);
        }
      }
    }
  }

  private void GetKeepWeapons()
  {
    keepWeapons.Clear();
    string weaponsSerialized = CVar.FindCVar("m8f_is_KeepWeapons").GetString();
    int size = weaponsSerialized.length();
    string currentWeapon = "";
    for (int i = 0; i < size; ++i)
    {
      currentWeapon = "";
      while (weaponsSerialized.CharAt(i) != ',' && i < size)
      {
        currentWeapon.AppendFormat("%c", weaponsSerialized.CharCodeAt(i));
        ++i;
      }
      keepWeapons.Push(currentWeapon);
    }
  }

  private bool WeaponIsInKeepList(string weaponClass)
  {
    int size = keepWeapons.size();
    for (int i = 0; i < size; ++i)
    {
      if (weaponClass == keepWeapons[i]) { return true; }
    }
    return false;
  }

  /** resets weapons, even if they are undroppable
   * ammo should be reset after resetting weapons.
   */
  private void ResetWeapons(PlayerPawn player)
  {
    DropItem drop = player.GetDropItems();

    GetKeepWeapons();

    // remove weapons even if they are undroppable
    // removing an item invalidates the iterator, so
    // 1. remember weapon classes
    Array<string> weapons;
    for (let item = player.Inv; item; item = item.Inv)
    {
      if (item is "Weapon")
      {
        string weaponClass = item.GetClassName();
        if (!WeaponIsInKeepList(weaponClass))
        {
          weapons.push(weaponClass);
        }
      }
    }

    // 2. Remove remembered weapon classes
    int size = weapons.Size();
    for (int i = 0; i < size; ++i)
    {
      player.A_TakeInventory(weapons[i]);
    }

    // If the player has any weapons in StartItem, set them here
    string lastStartWeapon = ""; // to set default weapon
    if (drop != null)
    {
      for(DropItem di = drop; di != null; di=di.Next)
      {
        if(di.Name == 'None') { continue; }

        let weptype = (class<weapon>)(di.Name);

        if(weptype != null)
        {
          lastStartWeapon = di.Name;
          player.A_SetInventory(di.Name, di.Amount);
        }
      }
    }
    if (lastStartWeapon != "")
    {
      let weaponInInv = player.FindInventory(lastStartWeapon);
      player.UseInventory(weaponInInv);
    }
  }

  private void ResetAmmo(PlayerPawn player)
  {
    DropItem drop = player.GetDropItems();

    // Remove all ammo, except that with the UNDROPPABLE flag
    // 1. Remember ammo classes
    Array<string> ammos;
    for (let item = player.Inv; item; item = item.Inv)
    {
      if(item is "Ammo") { ammos.Push(item.GetClassName()); }
    }
    // 2. Remove
    int size = ammos.Size();
    for (int i = 0; i < size; ++i)
    {
      player.A_TakeInventory(ammos[i]);
    }

    //If the player has any ammo in StartItem, set it here
    double ammoMultiplier = CVar.FindCVar("m8f_is_StartAmmoPercent").GetInt() / 100.0;
    if (drop != null)
    {
      for(DropItem di = drop; di != null; di = di.Next)
      {
        if (di.Name == 'None') { continue; }

        let ammotype = (class<ammo>)(di.Name);
        if (ammotype != null)
        {
          player.A_SetInventory(di.Name, di.Amount * ammoMultiplier);
        }
      }
    }
  }

  private void MaybeAddBackpack(PlayerPawn player)
  {
    bool startWithBackpack = CVar.FindCVar("m8f_is_StartWithBackpack").GetInt();
    if (!startWithBackpack) { return; }

    player.GiveInventoryType("BackpackItem");
  }

  private static bool IsTitlemap()
  {
    bool isTitlemap = (level.mapname == "TITLEMAP");
    return isTitlemap;
  }

  // private: //////////////////////////////////////////////////////////////////

  private Array<string> keepWeapons;

} // class m8f_is_EventHandler
